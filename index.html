<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Geometric Protocol</title>
    <style>
        :root {
            --neon-green: #0f0;
            --alert-red: #ff003c;
            --enemy-cyan: #00f3ff;
            --boss-magenta: #ff00ff;
            --shield-blue: #00aaff;
            --rocket-orange: #ffaa00;
            --scatter-purple: #bf00ff;
            --health-white: #ffffff;
            --gold: #ffd700;
            --turquoise: #40e0d0;
            --dark-bg: #050505;
            --panel-bg: #0a0a0a;
        }
        
        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--dark-bg);
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: var(--neon-green);
            user-select: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #game-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            width: 100%;
            background: #000;
        }

        #canvas1 {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* DASHBOARD (Bottom Bar) */
        #dashboard {
            height: 80px;
            min-height: 80px;
            background: var(--panel-bg);
            border-top: 2px solid var(--neon-green);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.1);
            z-index: 30;
        }

        .stat-block {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            min-width: 80px;
        }
        
        .stat-label {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
            width: 100%;
            display: flex;
            justify-content: space-between;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px currentColor;
            white-space: nowrap;
        }

        /* NEW HULL BAR STYLES */
        .hull-bar-container {
            width: 100%;
            height: 12px;
            background: rgba(50, 0, 0, 0.5);
            border: 1px solid var(--alert-red);
            position: relative;
        }
        
        .hull-bar-fill {
            height: 100%;
            width: 100%;
            background: var(--alert-red);
            box-shadow: 0 0 8px var(--alert-red);
            transition: width 0.2s ease-out;
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        .config-btn {
            background: #003300;
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 12px;
        }

        .config-btn:hover, .config-btn.active {
            background: var(--neon-green);
            color: #000;
            box-shadow: 0 0 15px var(--neon-green);
        }

        .battle-btn {
            background: #330000;
            color: var(--alert-red);
            border: 1px solid var(--alert-red);
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 12px;
        }

        .battle-btn:hover, .battle-btn.active {
            background: var(--alert-red);
            color: #000;
            box-shadow: 0 0 15px var(--alert-red);
        }

        /* POPUP MENU */
        .controls-popup {
            position: absolute;
            bottom: 80px;
            right: 0;
            width: 300px;
            background: rgba(10, 15, 10, 0.95);
            border: 1px solid var(--neon-green);
            border-bottom: none;
            padding: 15px;
            transform: translateY(120%);
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            z-index: 25;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: -5px -5px 20px rgba(0,0,0,0.5);
        }

        .controls-popup.open { transform: translateY(0); }

        .control-header {
            border-bottom: 1px dashed var(--neon-green);
            margin-bottom: 10px;
            padding-bottom: 5px;
            font-weight: bold;
            text-align: center;
        }

        .control-group { margin-bottom: 12px; }
        .control-group label {
            display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; text-transform: uppercase;
        }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 12px; width: 12px; background: var(--neon-green); margin-top: -4px; cursor: pointer; border: 1px solid #000; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #003300; border: 1px solid var(--neon-green); }

        .toggle-group { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; border-top: 1px dashed #003300; padding-top: 10px; }
        .checkbox-wrapper { display: flex; align-items: center; font-size: 10px; cursor: pointer; width: 45%; }
        .checkbox-wrapper input { margin-right: 5px; cursor: pointer; }

        input[type="file"] { font-size: 10px; color: var(--neon-green); width: 100%; margin-top: 5px; }
        input[type="file"]::file-selector-button { background: #003300; border: 1px solid var(--neon-green); color: var(--neon-green); padding: 4px 8px; cursor: pointer; font-family: inherit; margin-right: 10px; }

        /* OVERLAYS */
        .boss-container {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 50%; display: none; z-index: 30; pointer-events: none;
        }
        .boss-label { text-align: center; color: var(--boss-magenta); font-weight: bold; font-size: 12px; margin-bottom: 2px; text-shadow: 0 0 5px var(--boss-magenta); letter-spacing: 2px; }
        .boss-sublabel { text-align: center; color: #fff; font-size: 10px; margin-bottom: 4px; opacity: 0.8; }
        .boss-health-bar { width: 100%; height: 15px; border: 1px solid var(--boss-magenta); background: rgba(20, 0, 20, 0.8); position: relative; }
        .boss-health-fill { height: 100%; width: 100%; background: var(--boss-magenta); box-shadow: 0 0 10px var(--boss-magenta); transition: width 0.1s; }

        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px; pointer-events: none; z-index: 10; opacity: 1;
        }
        .scanlines.off { opacity: 0; }
        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%); pointer-events: none; z-index: 11;
        }
        .damage-flash {
            position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(255,0,0,0.3); pointer-events: none; opacity: 0; transition: opacity 0.1s; z-index: 15;
        }
        .glitch { animation: glitch 1s linear infinite; }
        @keyframes glitch {
            2%, 64% { transform: translate(2px,0) skew(0deg); } 4%, 60% { transform: translate(-2px,0) skew(0deg); } 62% { transform: translate(0,0) skew(5deg); }
        }
        .audio-viz { height: 4px; background: #003300; margin-top: 5px; width: 0%; transition: width 0.1s; }
        
        /* MAIN OVERLAY (Top Left) */
        .main-overlay {
            position: absolute; top: 20px; left: 20px; pointer-events: none; text-transform: uppercase;
            background: rgba(10, 15, 10, 0.85); padding: 10px; border: 1px solid var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green); z-index: 20;
        }
        .main-overlay h1 { font-size: 14px; margin: 0; letter-spacing: 2px; text-shadow: 0 0 5px var(--neon-green); }
        .main-overlay p { font-size: 10px; margin: 5px 0 0 0; opacity: 0.8; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="scanline-layer" class="scanlines"></div>
        <div class="vignette"></div>
        <div id="dmg-overlay" class="damage-flash"></div>
        
        <!-- Boss UI -->
        <div id="boss-ui" class="boss-container">
            <div class="boss-label">WARNING: BOSS DETECTED</div>
            <div id="boss-name" class="boss-sublabel">LEVEL 1: TRIANGLE CRAFT</div>
            <div class="boss-health-bar">
                <div id="boss-fill" class="boss-health-fill"></div>
            </div>
        </div>

        <canvas id="canvas1"></canvas>
    </div>

    <!-- POPUP CONTROLS MENU -->
    <div id="controls-panel" class="controls-popup">
        <div class="control-header">SYSTEM CONFIG</div>
        
        <!-- SYSTEM INFO MOVED HERE -->
        <div class="control-group" style="text-align: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed #333;">
            <div class="glitch" style="font-weight: bold; color: var(--neon-green); margin-bottom: 5px;">GEO_MANDALA_V4.5</div>
            <div style="font-size: 10px; color: #888; display: flex; justify-content: space-between;">
                <span>PARTICLES: <span id="particle-count" style="color: #fff;">0</span></span>
                <span>FPS: <span id="fps-count" style="color: #fff;">60</span></span>
            </div>
        </div>

        <div class="control-group"><label>UPLOAD IMAGE DATA</label><input type="file" id="image-upload" accept="image/*"></div>
        <div class="control-group"><label>Interaction Radius <span id="val-radius">100</span></label><input type="range" id="radius" min="0" max="300" value="100"></div>
        <div class="control-group"><label>Return Speed <span id="val-speed">10</span></label><input type="range" id="speed" min="1" max="40" value="10"></div>
        <div class="control-group"><label>Glitch Intensity <span id="val-glitch">1</span></label><input type="range" id="glitch" min="0" max="50" value="1"></div>
        <div class="control-group"><label>Particle Size <span id="val-size">100%</span></label><input type="range" id="psize" min="50" max="300" value="100"></div>
        <div class="toggle-group">
            <label class="checkbox-wrapper"><input type="checkbox" id="toggle-scanlines" checked> Scanlines</label>
            <label class="checkbox-wrapper"><input type="checkbox" id="toggle-breath"> Breathe</label>
            <label class="checkbox-wrapper" style="width: 100%; border-top: 1px dashed #003300; padding-top: 8px; margin-top: 4px;"><input type="checkbox" id="toggle-audio"> Audio Reactive</label>
            <div id="viz-bar" class="audio-viz"></div>
        </div>
    </div>

    <!-- BOTTOM DASHBOARD -->
    <div id="dashboard">
        <div class="stat-block">
            <div class="stat-label">SYSTEM STATUS</div>
            <div class="stat-value" id="status-text" style="font-size: 12px; color: var(--neon-green)">ONLINE</div>
        </div>
        
        <!-- NEW HULL BAR -->
        <div class="stat-block" style="flex-grow: 1; max-width: 200px; margin: 0 10px;">
            <div class="stat-label">
                <span>HULL INTEGRITY</span>
                <span id="health-text" style="color: var(--alert-red)">100%</span>
            </div>
            <div class="hull-bar-container">
                <div id="health-fill" class="hull-bar-fill"></div>
            </div>
        </div>

        <div class="stat-block">
            <div class="stat-label">SCORE</div>
            <div class="stat-value" id="score-val">0</div>
        </div>
        <div class="stat-block">
            <div class="stat-label">SHIELD</div>
            <div class="stat-value" id="shield-val" style="color: var(--shield-blue); font-size: 14px;">OFFLINE</div>
        </div>
        <div class="stat-block">
            <div class="stat-label">WEAPON SYSTEM</div>
            <div class="stat-value" id="weapon-val" style="color: var(--neon-green); font-size: 14px;">STANDARD</div>
        </div>
        
        <div class="btn-group">
            <button id="battle-btn" class="battle-btn">BATTLE MODE</button>
            <button id="config-btn" class="config-btn">SYSTEM MENU</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        
        function resizeCanvas() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            // We will call initParticles in main init 
        }

        const config = {
            mouseRadius: 100, returnSpeed: 10, glitchIntensity: 0.005, glitchForce: 1, particleSizeMult: 1,
            breathing: false, breathPhase: 0, audioEnabled: false, audioVolume: 0, audioHigh: 0,
            gameMode: false, score: 0, health: 100, bossLevel: 1
        };

        let audioCtx, analyser, dataArray;
        const keys = { w: false, a: false, s: false, d: false, space: false, up: false, left: false, down: false, right: false };
        
        // --- SOUND SYSTEM ---
        const sfx = {
            ctx: null,
            init: function() {
                if(!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            play: function(type) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime;
                
                if (type === 'shoot') {
                    // DISABLED AS PER REQUEST
                    // osc.type = 'sine'; 
                    // osc.frequency.setValueAtTime(1500, now); 
                    // osc.frequency.exponentialRampToValueAtTime(500, now + 0.1);
                    // gain.gain.setValueAtTime(0.02, now); 
                    // gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    // osc.start(now);
                    // osc.stop(now + 0.1);
                } else if (type === 'explosion') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                } else if (type === 'powerup') {
                    osc.type = 'sine'; // Softest wave
                    osc.frequency.setValueAtTime(300, now); // Low Start
                    osc.frequency.linearRampToValueAtTime(600, now + 0.2); // Low End
                    gain.gain.setValueAtTime(0.05, now); // Quiet
                    gain.gain.linearRampToValueAtTime(0, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                } else if (type === 'levelup') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(440, now);
                    osc.frequency.setValueAtTime(880, now + 0.1);
                    osc.frequency.setValueAtTime(1760, now + 0.2);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.6);
                    osc.start(now);
                    osc.stop(now + 0.6);
                }
            }
        };

        window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = true; break; case 'a': keys.a = true; break; case 's': keys.s = true; break; case 'd': keys.d = true; break;
                case ' ': keys.space = true; break; case 'arrowup': keys.up = true; break; case 'arrowleft': keys.left = true; break; case 'arrowdown': keys.down = true; break; case 'arrowright': keys.right = true; break;
            }
        });
        window.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = false; break; case 'a': keys.a = false; break; case 's': keys.s = false; break; case 'd': keys.d = false; break;
                case ' ': keys.space = false; break; case 'arrowup': keys.up = false; break; case 'arrowleft': keys.left = false; break; case 'arrowdown': keys.down = false; break; case 'arrowright': keys.right = false; break;
            }
        });
        
        let isMouseDown = false;
        canvas.addEventListener('mousedown', () => isMouseDown = true);
        canvas.addEventListener('mouseup', () => isMouseDown = false);
        
        const mouse = { x: null, y: null, radius: config.mouseRadius };
        canvas.addEventListener('mousemove', function(event) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = event.clientX - rect.left; mouse.y = event.clientY - rect.top;
        });
        canvas.addEventListener('touchmove', function(event) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = event.touches[0].clientX - rect.left; mouse.y = event.touches[0].clientY - rect.top;
        }, {passive: true});
        canvas.addEventListener('touchend', function() { mouse.x = null; mouse.y = null; isMouseDown = false; });

        // UI REFS
        const ui = {
            radius: document.getElementById('radius'), speed: document.getElementById('speed'), glitch: document.getElementById('glitch'), psize: document.getElementById('psize'),
            scanlines: document.getElementById('toggle-scanlines'), breath: document.getElementById('toggle-breath'), audio: document.getElementById('toggle-audio'),
            upload: document.getElementById('image-upload'), viz: document.getElementById('viz-bar'),
            status: document.getElementById('status-text'), score: document.getElementById('score-val'),
            
            healthText: document.getElementById('health-text'), healthFill: document.getElementById('health-fill'),
            
            shield: document.getElementById('shield-val'), weapon: document.getElementById('weapon-val'), 
            configBtn: document.getElementById('config-btn'), battleBtn: document.getElementById('battle-btn'),
            controlsPanel: document.getElementById('controls-panel'), dmgOverlay: document.getElementById('dmg-overlay'),
            boss: document.getElementById('boss-ui'), bossFill: document.getElementById('boss-fill'), bossName: document.getElementById('boss-name'),
            labels: { radius: document.getElementById('val-radius'), speed: document.getElementById('val-speed'), glitch: document.getElementById('val-glitch'), psize: document.getElementById('val-size') }
        };

        ui.configBtn.addEventListener('click', () => { ui.controlsPanel.classList.toggle('open'); ui.configBtn.classList.toggle('active'); });
        ui.radius.addEventListener('input', (e) => { config.mouseRadius = parseInt(e.target.value); ui.labels.radius.innerText = config.mouseRadius; mouse.radius = config.mouseRadius; });
        ui.speed.addEventListener('input', (e) => { config.returnSpeed = parseInt(e.target.value); ui.labels.speed.innerText = config.returnSpeed; });
        ui.glitch.addEventListener('input', (e) => { let val = parseInt(e.target.value); config.glitchForce = val; config.glitchIntensity = val > 0 ? 0.005 + (val * 0.002) : 0; ui.labels.glitch.innerText = val; });
        ui.psize.addEventListener('input', (e) => { let val = parseInt(e.target.value); config.particleSizeMult = val / 100; ui.labels.psize.innerText = val + '%'; });
        ui.scanlines.addEventListener('change', (e) => { const el = document.getElementById('scanline-layer'); if(e.target.checked) el.classList.remove('off'); else el.classList.add('off'); });
        ui.breath.addEventListener('change', (e) => { config.breathing = e.target.checked; });

        // BATTLE MODE TOGGLE
        ui.battleBtn.addEventListener('click', () => {
            sfx.init(); // Init audio context on user click
            config.gameMode = !config.gameMode;
            if(config.gameMode) {
                ui.battleBtn.classList.add('active');
                ui.status.innerText = "BATTLE MODE ACTIVE"; ui.status.style.color = "var(--alert-red)"; 
                resetGame();
            } else {
                ui.battleBtn.classList.remove('active');
                ui.status.innerText = "ONLINE"; ui.status.style.color = "var(--neon-green)";
                bullets = []; enemies = []; rockets = []; powerups = []; explosions = []; boss = null; ui.boss.style.display = 'none';
                particlesArray.forEach(p => { p.dead = false; p.respawnTimer = 0; });
                initParticles(1); // Reset to base visual
            }
        });
        
        function resetGame() {
            ship.x = canvas.width / 2; ship.y = canvas.height / 2; ship.velX = 0; ship.velY = 0;
            ship.shieldTimer = 0; ship.shieldStacks = 0; ship.rocketTimer = 0; ship.scatterTimer = 0;
            config.score = 0; config.health = 100; config.bossLevel = 1;
            ui.score.innerText = '0'; ui.healthText.innerText = '100%'; ui.healthFill.style.width = '100%';
            ui.shield.innerText = "OFFLINE"; ui.shield.style.color = "var(--shield-blue)"; ui.weapon.innerText = "STANDARD"; ui.weapon.style.color = "var(--neon-green)";
            ui.boss.style.display = 'none'; boss = null; enemies = []; powerups = []; explosions = []; rockets = [];
            initParticles(1);
        }

        ui.audio.addEventListener('change', async (e) => {
            if (e.target.checked) {
                sfx.init();
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioCtx = sfx.ctx; // Reuse same context
                    analyser = audioCtx.createAnalyser();
                    const source = audioCtx.createMediaStreamSource(stream); source.connect(analyser); analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount; dataArray = new Uint8Array(bufferLength); config.audioEnabled = true;
                } catch(err) { e.target.checked = false; alert("Microphone access denied."); }
            } else { config.audioEnabled = false; ui.viz.style.width = "0%"; }
        });
        
        ui.upload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader(); reader.onload = (event) => { const img = new Image(); img.onload = () => { processImage(img); }; img.src = event.target.result; }; reader.readAsDataURL(file);
            }
        });

        function processImage(image) {
            particlesArray = []; 
            const maxWidth = canvas.width * 0.8; const maxHeight = canvas.height * 0.8;
            const scale = Math.min(maxWidth / image.width, maxHeight / image.height);
            const w = image.width * scale; const h = image.height * scale;
            const offX = (canvas.width - w) / 2; const offY = (canvas.height - h) / 2;
            ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(image, offX, offY, w, h);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); ctx.clearRect(0, 0, canvas.width, canvas.height);
            const data = imageData.data; const gap = 4; 
            for (let y = 0; y < canvas.height; y += gap) {
                for (let x = 0; x < canvas.width; x += gap) {
                    const index = (y * canvas.width + x) * 4; const alpha = data[index + 3]; const red = data[index]; const green = data[index + 1]; const blue = data[index + 2]; const brightness = (red + green + blue) / 3;
                    if (alpha > 128 && brightness > 40) { let style = Math.random() > 0.9 ? 'dash' : 'dot'; particlesArray.push(new Particle(x, y, false, style)); }
                }
            }
            document.getElementById('particle-count').innerText = particlesArray.length;
        }

        let particlesArray = []; let bullets = []; let rockets = []; let enemies = []; let powerups = []; let explosions = []; let boss = null; let frameCount = 0;
        const particleColor = '#00ff41'; 

        class Ship {
            constructor() {
                this.x = canvas.width / 2; this.y = canvas.height / 2; this.size = 15; this.angle = 0; this.velX = 0; this.velY = 0;
                this.friction = 0.92; this.acceleration = 0.8; this.fireTimer = 0; this.fireRate = 8; this.invulnerable = 0;
                this.shieldTimer = 0; this.shieldStacks = 0;
                this.rocketTimer = 0; this.scatterTimer = 0; 
            }
            update() {
                if (mouse.x !== null && mouse.y !== null) { const dx = mouse.x - this.x; const dy = mouse.y - this.y; this.angle = Math.atan2(dy, dx); }
                if (keys.w || keys.up) this.velY -= this.acceleration; if (keys.s || keys.down) this.velY += this.acceleration;
                if (keys.a || keys.left) this.velX -= this.acceleration; if (keys.d || keys.right) this.velX += this.acceleration;
                this.velX *= this.friction; this.velY *= this.friction; this.x += this.velX; this.y += this.velY;
                if (this.x < 0) this.x = 0; if (this.x > canvas.width) this.x = canvas.width; if (this.y < 0) this.y = 0; if (this.y > canvas.height) this.y = canvas.height;
                
                if (this.rocketTimer > 0) this.rocketTimer--; if (this.scatterTimer > 0) this.scatterTimer--;
                if (this.fireTimer > 0) this.fireTimer--;
                if (this.fireTimer === 0) { this.fire(); }
                
                if(this.invulnerable > 0) this.invulnerable--;
                if(this.shieldTimer > 0) {
                    this.shieldTimer--;
                    if(this.shieldTimer === 0) { this.shieldStacks = 0; ui.shield.innerText = "OFFLINE"; ui.shield.style.color = "var(--shield-blue)"; } 
                    else { let lvl = this.shieldStacks > 0 ? ` (MAX)` : ""; ui.shield.innerText = Math.ceil(this.shieldTimer / 60) + "s" + lvl; ui.shield.style.color = "#fff"; }
                }
            }
            fire() {
                if (this.rocketTimer > 0) { rockets.push(new Rocket(this.x, this.y, this.angle)); this.fireTimer = 15; sfx.play('shoot'); } 
                else if (this.scatterTimer > 0) { for(let i=-2; i<=2; i++) { bullets.push(new Bullet(this.x, this.y, this.angle + (i * 0.15))); } this.fireTimer = 20; sfx.play('shoot'); } 
                else { bullets.push(new Bullet(this.x, this.y, this.angle)); this.fireTimer = this.fireRate; sfx.play('shoot'); }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                if(this.shieldTimer > 0) {
                    ctx.beginPath(); let radius = 30 + (this.shieldStacks * 15); ctx.arc(0, 0, radius, 0, Math.PI*2);
                    ctx.strokeStyle = `rgba(0, 170, 255, ${0.5 + Math.sin(Date.now()/100)*0.3})`; ctx.lineWidth = 2 + this.shieldStacks; ctx.stroke();
                    if (this.shieldStacks > 0) { ctx.beginPath(); ctx.arc(0, 0, radius - 5, Date.now()/200, Date.now()/200 + Math.PI*1.5); ctx.strokeStyle = 'rgba(0,255,255,0.5)'; ctx.stroke(); }
                    ctx.shadowBlur = 10; ctx.shadowColor = '#00aaff';
                }
                if(this.invulnerable > 0 && Math.floor(Date.now() / 50) % 2 === 0) { ctx.strokeStyle = 'rgba(255, 0, 60, 0.5)'; } else { ctx.strokeStyle = '#ff003c'; }
                ctx.lineWidth = 2; ctx.shadowBlur = 10; ctx.shadowColor = '#ff003c';
                ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, -10); ctx.lineTo(-5, 0); ctx.lineTo(-10, 10); ctx.closePath(); ctx.stroke();
                if (keys.w || keys.up || keys.a || keys.s || keys.d) { ctx.beginPath(); ctx.moveTo(-8, 0); ctx.lineTo(-18, 0); ctx.strokeStyle = '#ffaa00'; ctx.stroke(); }
                ctx.restore();
            }
        }
        
        class Bullet {
            constructor(x, y, angle) { this.x = x; this.y = y; this.speed = 20; this.velX = Math.cos(angle) * this.speed; this.velY = Math.sin(angle) * this.speed; this.life = 100; }
            update() { this.x += this.velX; this.y += this.velY; this.life--; }
            draw() { ctx.fillStyle = '#ff003c'; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI * 2); ctx.fill(); }
        }
        class Rocket {
            constructor(x, y, angle) { this.x = x; this.y = y; this.speed = 8; this.velX = Math.cos(angle) * this.speed; this.velY = Math.sin(angle) * this.speed; this.life = 120; this.size = 6; }
            update() { this.x += this.velX; this.y += this.velY; this.life--; }
            draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(Math.atan2(this.velY, this.velX)); ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.rect(-6, -3, 12, 6); ctx.fill(); ctx.beginPath(); ctx.moveTo(-6, 0); ctx.lineTo(-15, 0); ctx.strokeStyle = 'rgba(255, 100, 0, 0.8)'; ctx.stroke(); ctx.restore(); }
        }
        class Explosion {
            constructor(x, y) { this.x = x; this.y = y; this.radius = 1; this.maxRadius = 60; this.life = 30; }
            update() { this.radius += (this.maxRadius - this.radius) * 0.2; this.life--; }
            draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 100, 0, ${this.life/30})`; ctx.fill(); ctx.strokeStyle = `rgba(255, 255, 200, ${this.life/30})`; ctx.stroke(); }
        }
        class PowerUp {
            constructor() {
                this.x = Math.random() * (canvas.width - 100) + 50; this.y = Math.random() * (canvas.height - 100) + 50;
                const r = Math.random(); 
                // 30% Shield, 30% Rocket, 30% Scatter, 10% Health
                if (r < 0.3) this.type = 'shield'; 
                else if (r < 0.6) this.type = 'rocket';
                else if (r < 0.9) this.type = 'scatter';
                else this.type = 'health';
                this.size = 15; this.life = 600; this.angle = 0;
            }
            update() { this.life--; this.angle += 0.05; }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                if (this.type === 'shield') { ctx.strokeStyle = '#00aaff'; ctx.shadowColor = '#00aaff'; } 
                else if (this.type === 'rocket') { ctx.strokeStyle = '#ffaa00'; ctx.shadowColor = '#ffaa00'; }
                else if (this.type === 'scatter') { ctx.strokeStyle = '#bf00ff'; ctx.shadowColor = '#bf00ff'; }
                else { ctx.strokeStyle = '#ffffff'; ctx.shadowColor = '#ffffff'; }
                ctx.shadowBlur = 15; ctx.lineWidth = 2; ctx.beginPath(); ctx.rect(-8, -8, 16, 16); ctx.stroke();
                if (this.type === 'shield') { ctx.fillStyle = '#00aaff'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); } 
                else if (this.type === 'rocket') { ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); }
                else if (this.type === 'scatter') { ctx.fillStyle = '#bf00ff'; ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(5, 5); ctx.lineTo(-5, 5); ctx.fill(); }
                else { ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.rect(-2, -5, 4, 10); ctx.rect(-5, -2, 10, 4); ctx.fill(); }
                ctx.restore();
            }
        }
        class Enemy {
            constructor(type = 'grunt', bossLevel = 1) {
                this.type = type; this.bossLevel = bossLevel; this.size = type === 'grunt' ? 15 : 60; this.spawnSwarmTimer = 0;
                if (type === 'boss') {
                    if(bossLevel === 1) this.hp = 200; if(bossLevel === 2) this.hp = 400; if(bossLevel === 3) this.hp = 600; if(bossLevel === 4) this.hp = 1000; if(bossLevel >= 5) this.hp = 1500 + ((bossLevel-5)*500);
                } else { this.hp = 1; this.size = type === 'swarm' ? 8 : 15; }
                this.maxHp = this.hp;
                if (type === 'swarm') { this.x = boss ? boss.x : canvas.width/2; this.y = boss ? boss.y : canvas.height/2; } 
                else { if (Math.random() < 0.5) { this.x = Math.random() < 0.5 ? -50 : canvas.width + 50; this.y = Math.random() * canvas.height; } else { this.x = Math.random() * canvas.width; this.y = Math.random() < 0.5 ? -50 : canvas.height + 50; } }
                
                // -- NEW SPEED LOGIC --
                let baseSpeed = type === 'grunt' ? 2 + Math.random() : type === 'swarm' ? 4 : 1;
                let speedMultiplier = 1 + ((bossLevel - 1) * 0.15); // 15% faster per level
                this.speed = baseSpeed * speedMultiplier;
                
                this.angle = 0; this.rotationSpeed = Math.random() * 0.05;
                this.color = '#00f3ff'; if (type === 'swarm') this.color = '#ff3333';
                if (type === 'boss') { if (bossLevel === 1) this.color = '#ff00ff'; if (bossLevel === 2) this.color = '#222'; if (bossLevel === 3) this.color = '#ffd700'; if (bossLevel === 4) this.color = '#40e0d0'; if (bossLevel >= 5) this.color = '#fff'; }
            }
            update(target) {
                const dx = target.x - this.x; const dy = target.y - this.y; const dist = Math.hypot(dx, dy);
                this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; this.angle += this.rotationSpeed;
                if (this.type === 'boss' && this.bossLevel >= 5) { this.spawnSwarmTimer++; if(this.spawnSwarmTimer > 60) { enemies.push(new Enemy('swarm')); this.spawnSwarmTimer = 0; } }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                if (this.type === 'boss') {
                     ctx.lineWidth = 3; ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.strokeStyle = this.color;
                     if (this.bossLevel === 1) { ctx.beginPath(); for(let i=0; i<3; i++) { let a = (i/3) * Math.PI*2; ctx.lineTo(Math.cos(a)*50, Math.sin(a)*50); } ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.rect(-15,-15,30,30); ctx.stroke(); } 
                     else if (this.bossLevel === 2) { ctx.strokeStyle = '#0f0'; ctx.fillStyle = '#111'; ctx.beginPath(); ctx.rect(-50, -50, 100, 100); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-40, -40); ctx.lineTo(40, 40); ctx.stroke(); ctx.beginPath(); ctx.moveTo(40, -40); ctx.lineTo(-40, 40); ctx.stroke(); } 
                     else if (this.bossLevel === 3) { ctx.strokeStyle = '#ffd700'; ctx.beginPath(); ctx.moveTo(0, -60); ctx.lineTo(50, 0); ctx.lineTo(0, 60); ctx.lineTo(-50, 0); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-50,0); ctx.lineTo(50,0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,-60); ctx.lineTo(0,60); ctx.stroke(); ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill(); } 
                     else if (this.bossLevel === 4) { ctx.strokeStyle = '#40e0d0'; ctx.beginPath(); for(let i=0; i<5; i++) { let a = (i/5) * Math.PI*2; ctx.lineTo(Math.cos(a)*60, Math.sin(a)*60); } ctx.closePath(); ctx.stroke(); ctx.beginPath(); for(let i=0; i<5; i++) { let a = (i/5) * Math.PI*2 + Math.PI; ctx.lineTo(Math.cos(a)*30, Math.sin(a)*30); } ctx.closePath(); ctx.stroke(); } 
                     else if (this.bossLevel >= 5) { ctx.strokeStyle = '#fff'; ctx.beginPath(); for(let i=0; i<3; i++) { let a = (i/3) * Math.PI*2 - Math.PI/2; ctx.lineTo(Math.cos(a)*70, Math.sin(a)*70); } ctx.closePath(); ctx.stroke(); ctx.beginPath(); for(let i=0; i<3; i++) { let a = (i/3) * Math.PI*2 + Math.PI/2; ctx.lineTo(Math.cos(a)*70, Math.sin(a)*70); } ctx.closePath(); ctx.stroke(); ctx.shadowBlur = 30; ctx.shadowColor = '#fff'; ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.stroke(); }
                } else {
                    ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.shadowColor = this.color; ctx.shadowBlur = 10;
                    if (this.type === 'swarm') { ctx.beginPath(); ctx.moveTo(8, 0); ctx.lineTo(0, 8); ctx.lineTo(-8, 0); ctx.lineTo(0, -8); ctx.closePath(); ctx.stroke(); } 
                    else { ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.closePath(); ctx.stroke(); }
                }
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, fixed = false, style = 'dot') {
                this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height;
                this.baseX = x; this.baseY = y;
                this.size = (Math.random() * 2) + 1; this.density = (Math.random() * 30) + 1;
                this.fixed = fixed; this.style = style; this.dead = false; this.respawnTimer = 0;
            }
            draw() {
                if (this.dead) return;
                ctx.fillStyle = particleColor; ctx.beginPath();
                let audioBoost = config.audioEnabled ? (config.audioVolume * 0.05) : 0;
                let currentSize = (this.size + audioBoost) * config.particleSizeMult;
                if (this.style === 'dash') ctx.rect(this.x, this.y, currentSize, currentSize * 3);
                else ctx.rect(this.x, this.y, currentSize, currentSize);
                ctx.closePath(); ctx.fill();
            }
            update() {
                if (this.dead) {
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0) { this.dead = false; this.x = Math.random() > 0.5 ? 0 : canvas.width; this.y = Math.random() * canvas.height; }
                    return;
                }
                let dynamicGlitchForce = config.glitchForce; let dynamicGlitchChance = config.glitchIntensity;
                if (config.audioEnabled && config.audioHigh > 50) { dynamicGlitchForce += 5; dynamicGlitchChance += 0.1; }
                if (dynamicGlitchForce > 0 && Math.random() > (1 - dynamicGlitchChance)) { this.x += (Math.random() - 0.5) * (dynamicGlitchForce * 5); this.y += (Math.random() - 0.5) * (dynamicGlitchForce * 5); }
                let targetX = this.baseX; let targetY = this.baseY;
                const cx = canvas.width/2; const cy = canvas.height/2; const dxBase = this.baseX - cx; const dyBase = this.baseY - cy;
                let expansionFactor = 1;
                if (config.breathing) expansionFactor += (Math.sin(config.breathPhase) * 0.05);
                if (config.audioEnabled) expansionFactor += (config.audioVolume * 0.002); 
                if (expansionFactor !== 1) { targetX = cx + dxBase * expansionFactor; targetY = cy + dyBase * expansionFactor; }
                let maxDist = Math.max(1, config.mouseRadius); // Prevent 0
                let dx = (mouse.x !== null ? mouse.x : -1000) - this.x; let dy = (mouse.y !== null ? mouse.y : -1000) - this.y;
                if (config.gameMode) { dx = ship.x - this.x; dy = ship.y - this.y; maxDist = 50; }
                for(let exp of explosions) {
                    let ex = exp.x - this.x; let ey = exp.y - this.y; let edist = Math.sqrt(ex*ex + ey*ey);
                    if (edist === 0) edist = 0.001; // SAFETY CHECK
                    if (edist < exp.maxRadius) { dx = ex; dy = ey; maxDist = exp.maxRadius; this.x -= (dx/edist) * 10; this.y -= (dy/edist) * 10; }
                }
                let distance = Math.sqrt(dx * dx + dy * dy);
                if(distance === 0) distance = 0.001; // SAFETY CHECK
                let forceDirectionX = dx / distance; let forceDirectionY = dy / distance;
                let force = (maxDist - distance) / maxDist;
                let directionX = forceDirectionX * force * this.density; let directionY = forceDirectionY * force * this.density;
                if (distance < maxDist) { this.x -= directionX; this.y -= directionY; } 
                else {
                    if (this.x !== targetX) { let dx = this.x - targetX; let speedDivisor = Math.max(1, 50 - config.returnSpeed); if (config.audioEnabled && config.audioVolume > 100) speedDivisor /= 2; this.x -= dx / speedDivisor; }
                    if (this.y !== targetY) { let dy = this.y - targetY; let speedDivisor = Math.max(1, 50 - config.returnSpeed); if (config.audioEnabled && config.audioVolume > 100) speedDivisor /= 2; this.y -= dy / speedDivisor; }
                }
            }
        }
        
        const ship = new Ship(); 

        // -- DYNAMIC GEOMETRY GENERATION --
        function initParticles(level = 1) {
            particlesArray = [];
            const cx = canvas.width / 2; const cy = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) * 0.4; 

            function createLine(x1, y1, x2, y2, style='dot') {
                let dist = Math.hypot(x2 - x1, y2 - y1); let steps = dist / 6;
                for(let i=0; i<steps; i++) { let t = i/steps; particlesArray.push(new Particle(x1 + (x2-x1)*t, y1 + (y2-y1)*t, false, style)); }
            }

            if (level === 1) {
                // EYE / MANDALA
                for (let i = 0; i < 360; i += 15) { let rad = (i * Math.PI) / 180; let r = scale * 0.08; particlesArray.push(new Particle(cx + Math.cos(rad) * r, cy + Math.sin(rad) * r, true)); }
                for (let i = 0; i < 3; i++) { let a = (i * 120 - 90) * Math.PI/180; let x = cx + Math.cos(a)*scale*0.5; let y = cy + Math.sin(a)*scale*0.5; let a2 = ((i+1)*120-90)*Math.PI/180; let x2 = cx + Math.cos(a2)*scale*0.5; let y2 = cy + Math.sin(a2)*scale*0.5; createLine(x,y,x2,y2); }
                for (let i = 0; i < 3; i++) { let a = (i * 120 + 90) * Math.PI/180; let x = cx + Math.cos(a)*scale*0.5; let y = cy + Math.sin(a)*scale*0.5; let a2 = ((i+1)*120+90)*Math.PI/180; let x2 = cx + Math.cos(a2)*scale*0.5; let y2 = cy + Math.sin(a2)*scale*0.5; createLine(x,y,x2,y2); }
                for (let r = 0.6; r < 0.9; r += 0.08) { let rad = scale * r; let count = (2*Math.PI*rad)/5; for (let i = 0; i < count; i++) { let ang = (i/count)*Math.PI*2; if(Math.sin(ang*12)>0) particlesArray.push(new Particle(cx+Math.cos(ang)*rad, cy+Math.sin(ang)*rad)); } }
            } 
            else if (level === 2) {
                // HYPERCUBE (Approximated)
                let s = scale * 0.6; 
                // Inner Box
                createLine(cx-s/2, cy-s/2, cx+s/2, cy-s/2); createLine(cx+s/2, cy-s/2, cx+s/2, cy+s/2);
                createLine(cx+s/2, cy+s/2, cx-s/2, cy+s/2); createLine(cx-s/2, cy+s/2, cx-s/2, cy-s/2);
                // Outer Box
                let s2 = scale;
                createLine(cx-s2, cy-s2, cx+s2, cy-s2, 'dash'); createLine(cx+s2, cy-s2, cx+s2, cy+s2, 'dash');
                createLine(cx+s2, cy+s2, cx-s2, cy+s2, 'dash'); createLine(cx-s2, cy+s2, cx-s2, cy-s2, 'dash');
                // Connecting Lines
                createLine(cx-s/2, cy-s/2, cx-s2, cy-s2); createLine(cx+s/2, cy-s/2, cx+s2, cy-s2);
                createLine(cx+s/2, cy+s/2, cx+s2, cy+s2); createLine(cx-s/2, cy+s/2, cx-s2, cy+s2);
            }
            else if (level === 3) {
                // OCTAHEDRON
                let s = scale;
                createLine(cx, cy-s, cx+s*0.8, cy); createLine(cx+s*0.8, cy, cx, cy+s);
                createLine(cx, cy+s, cx-s*0.8, cy); createLine(cx-s*0.8, cy, cx, cy-s);
                createLine(cx-s*0.8, cy, cx+s*0.8, cy, 'dash'); createLine(cx, cy-s, cx, cy+s, 'dash');
                // Internal square
                createLine(cx-s*0.4, cy-s*0.4, cx+s*0.4, cy-s*0.4); createLine(cx+s*0.4, cy-s*0.4, cx+s*0.4, cy+s*0.4);
                createLine(cx+s*0.4, cy+s*0.4, cx-s*0.4, cy+s*0.4); createLine(cx-s*0.4, cy+s*0.4, cx-s*0.4, cy-s*0.4);
            }
            else if (level === 4) {
                // DODECAHEDRON (Pentagons)
                for(let j=0; j<2; j++) {
                    let r = scale * (j===0?0.6:1.0);
                    for(let i=0; i<5; i++) {
                        let a1 = (i/5)*Math.PI*2 - Math.PI/2; let a2 = ((i+1)/5)*Math.PI*2 - Math.PI/2;
                        createLine(cx+Math.cos(a1)*r, cy+Math.sin(a1)*r, cx+Math.cos(a2)*r, cy+Math.sin(a2)*r, j===1?'dash':'dot');
                    }
                }
                // Connect layers
                for(let i=0; i<5; i++) {
                    let a = (i/5)*Math.PI*2 - Math.PI/2;
                    createLine(cx+Math.cos(a)*scale*0.6, cy+Math.sin(a)*scale*0.6, cx+Math.cos(a)*scale, cy+Math.sin(a)*scale);
                }
            }
            else if (level >= 5) {
                // MERKABA (Star Tetrahedron)
                let s = scale;
                // Triangle Up
                let points1 = []; for(let i=0; i<3; i++) points1.push({x: cx+Math.cos((i*120-90)*Math.PI/180)*s, y: cy+Math.sin((i*120-90)*Math.PI/180)*s});
                createLine(points1[0].x, points1[0].y, points1[1].x, points1[1].y, 'dash');
                createLine(points1[1].x, points1[1].y, points1[2].x, points1[2].y, 'dash');
                createLine(points1[2].x, points1[2].y, points1[0].x, points1[0].y, 'dash');
                // Triangle Down
                let points2 = []; for(let i=0; i<3; i++) points2.push({x: cx+Math.cos((i*120+90)*Math.PI/180)*s, y: cy+Math.sin((i*120+90)*Math.PI/180)*s});
                createLine(points2[0].x, points2[0].y, points2[1].x, points2[1].y, 'dash');
                createLine(points2[1].x, points2[1].y, points2[2].x, points2[2].y, 'dash');
                createLine(points2[2].x, points2[2].y, points2[0].x, points2[0].y, 'dash');
                // Connect Tips
                for(let i=0; i<3; i++) createLine(points1[i].x, points1[i].y, points2[i].x, points2[i].y);
            }

            document.getElementById('particle-count').innerText = particlesArray.length;
        }

        let lastTime = 0;
        function animate(timeStamp) {
            const deltaTime = timeStamp - lastTime; lastTime = timeStamp; frameCount++;
            if (config.breathing) config.breathPhase += 0.02;
            if (config.audioEnabled && analyser) {
                analyser.getByteFrequencyData(dataArray); let sum = 0; for (let i = 0; i < dataArray.length; i++) { sum += dataArray[i]; } config.audioVolume = sum / dataArray.length; ui.viz.style.width = (config.audioVolume / 255 * 100) + "%"; ui.viz.style.background = `rgb(0, ${config.audioVolume + 50}, 0)`;
            }
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (config.gameMode) {
                if(config.health <= 0) { resetGame(); ui.dmgOverlay.style.opacity = 1; setTimeout(() => ui.dmgOverlay.style.opacity = 0, 100); }
                ship.update(); ship.draw();
                if (frameCount % 600 === 0 && powerups.length < 3) powerups.push(new PowerUp());
                
                // Update Weapon UI
                let wText = "STANDARD"; let wColor = "var(--neon-green)";
                if(ship.rocketTimer > 0) { wText = "ROCKETS " + (ship.rocketTimer/60).toFixed(1) + "s"; wColor = "var(--rocket-orange)"; }
                else if(ship.scatterTimer > 0) { wText = "SCATTER " + (ship.scatterTimer/60).toFixed(1) + "s"; wColor = "var(--scatter-purple)"; }
                ui.weapon.innerText = wText; ui.weapon.style.color = wColor;
                
                let spawnRate = Math.max(30, 120 - ((config.bossLevel - 1) * 15)); 
                let maxEnemies = 3 + ((config.bossLevel - 1) * 2);
                
                if (frameCount % spawnRate === 0 && enemies.length < maxEnemies) {
                    enemies.push(new Enemy('grunt', config.bossLevel));
                }

                if (config.score > 0 && config.score % 500 === 0 && !boss && config.score > 100) {
                     boss = new Enemy('boss', config.bossLevel); ui.boss.style.display = 'block'; ui.bossFill.style.width = '100%';
                     let bName = "UNKNOWN";
                     if(config.bossLevel===1) bName = "LEVEL 1: TRIANGLE CRAFT"; else if(config.bossLevel===2) bName = "LEVEL 2: BORG CUBE"; else if(config.bossLevel===3) bName = "LEVEL 3: GOLDEN OCTAHEDRON"; else if(config.bossLevel===4) bName = "LEVEL 4: DODECAHEDRON"; else if(config.bossLevel>=5) bName = "LEVEL 5: MERKABA SWARM";
                     ui.bossName.innerText = bName;
                }
                for (let i = explosions.length - 1; i >= 0; i--) {
                    let exp = explosions[i]; exp.update(); exp.draw();
                    if (exp.life <= 0) explosions.splice(i, 1);
                    else if (exp.life > 25) { 
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            let e = enemies[j]; if (Math.hypot(exp.x - e.x, exp.y - e.y) < exp.maxRadius) { e.hp -= 5; if(e.hp <= 0) { config.score += 25; enemies.splice(j, 1); sfx.play('explosion'); } }
                        }
                        if(boss && Math.hypot(exp.x - boss.x, exp.y - boss.y) < exp.maxRadius + boss.size) boss.hp -= 2;
                    }
                }
                for (let i = powerups.length - 1; i >= 0; i--) {
                    let p = powerups[i]; p.update(); p.draw();
                    if (p.life <= 0) { powerups.splice(i, 1); continue; }
                    if (Math.hypot(ship.x - p.x, ship.y - p.y) < 30) {
                        sfx.play('powerup');
                        if (p.type === 'shield') { ship.shieldTimer = 600; ship.invulnerable = 600; if(ship.shieldStacks < 2) ship.shieldStacks++; } 
                        else if (p.type === 'rocket') { ship.rocketTimer = 300; } 
                        else if (p.type === 'scatter') { ship.scatterTimer = 300; } 
                        else if (p.type === 'health') { config.health = Math.min(100, config.health + 50); 
                            ui.healthText.innerText = Math.ceil(config.health) + '%'; 
                            ui.healthFill.style.width = Math.ceil(config.health) + '%';
                        }
                        config.score += 50; powerups.splice(i, 1);
                    }
                }
                if (boss) {
                    boss.update(ship); boss.draw(); ui.bossFill.style.width = Math.max(0, (boss.hp / boss.maxHp * 100)) + "%";
                    let dist = Math.hypot(boss.x - ship.x, boss.y - ship.y);
                    let collisionDist = boss.size + ship.size + (ship.shieldTimer > 0 ? (30 + ship.shieldStacks*15) : 0);
                    if (dist < collisionDist) {
                         if (ship.shieldTimer > 0) { boss.hp -= 1; explosions.push(new Explosion(boss.x, boss.y)); let angle = Math.atan2(boss.y - ship.y, boss.x - ship.x); boss.x = ship.x + Math.cos(angle) * (collisionDist + 5); boss.y = ship.y + Math.sin(angle) * (collisionDist + 5); } 
                         else if (ship.invulnerable <= 0) { 
                             config.health -= 30; ship.invulnerable = 60; sfx.play('explosion');
                             ui.healthText.innerText = Math.ceil(config.health) + '%'; 
                             ui.healthFill.style.width = Math.max(0, config.health) + '%';
                             ship.velX -= (boss.x - ship.x) * 0.1; ship.velY -= (boss.y - ship.y) * 0.1; ui.dmgOverlay.style.opacity = 1; setTimeout(()=>ui.dmgOverlay.style.opacity=0, 100); 
                         }
                    }
                    if(boss.hp <= 0) { sfx.play('levelup'); explosions.push(new Explosion(boss.x, boss.y)); config.score += 500; config.bossLevel++; boss = null; ui.boss.style.display = 'none'; initParticles(config.bossLevel); }
                }
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let e = enemies[i]; e.update(ship); e.draw();
                    let dist = Math.hypot(e.x - ship.x, e.y - ship.y); let shieldRad = (ship.shieldTimer > 0) ? (30 + ship.shieldStacks*15) : 0; let colDist = e.size + ship.size + shieldRad;
                    if (dist < colDist) {
                        if (ship.shieldTimer > 0) { e.hp = 0; enemies.splice(i, 1); config.score += 10; explosions.push(new Explosion(e.x, e.y)); sfx.play('explosion'); } 
                        else if (ship.invulnerable <= 0) { 
                            config.health -= 10; ship.invulnerable = 30; sfx.play('explosion');
                            ui.healthText.innerText = Math.ceil(config.health) + '%'; 
                            ui.healthFill.style.width = Math.max(0, config.health) + '%';
                            enemies.splice(i, 1); ui.dmgOverlay.style.opacity = 0.5; setTimeout(()=>ui.dmgOverlay.style.opacity=0, 50); 
                        }
                    }
                }
                ui.score.innerText = config.score;
                for (let i = bullets.length - 1; i >= 0; i--) {
                    let b = bullets[i]; b.update(); b.draw();
                    if (b.life <= 0 || b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) { bullets.splice(i, 1); continue; }
                    let bulletHit = false;
                    if(boss && Math.hypot(b.x - boss.x, b.y - boss.y) < boss.size) { boss.hp -= 5; bulletHit = true; }
                    if(bulletHit) { bullets.splice(i, 1); continue; }
                    for (let j = enemies.length - 1; j >= 0; j--) { let e = enemies[j]; if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + 5) { e.hp--; if(e.hp <= 0) { config.score += 25; enemies.splice(j, 1); sfx.play('explosion'); } bulletHit = true; break; } }
                    if(bulletHit) { bullets.splice(i, 1); continue; }
                    for (let j = 0; j < particlesArray.length; j++) {
                         let p = particlesArray[j]; if (p.dead) continue;
                         if (Math.abs(b.x - p.x) > 20 || Math.abs(b.y - p.y) > 20) continue;
                         if (Math.hypot(b.x - p.x, b.y - p.y) < 20) { p.dead = true; p.respawnTimer = 300; config.score += 10; }
                    }
                }
                for (let i = rockets.length - 1; i >= 0; i--) {
                    let r = rockets[i]; r.update(); r.draw();
                    if (r.life <= 0 || r.x < 0 || r.x > canvas.width || r.y < 0 || r.y > canvas.height) { rockets.splice(i, 1); continue; }
                    let rocketHit = false;
                    if (boss && Math.hypot(r.x - boss.x, r.y - boss.y) < boss.size) rocketHit = true;
                    if (!rocketHit) { for (let e of enemies) { if (Math.hypot(r.x - e.x, r.y - e.y) < e.size + 5) { rocketHit = true; break; } } }
                    if (rocketHit) { explosions.push(new Explosion(r.x, r.y)); rockets.splice(i, 1); sfx.play('explosion'); }
                }
            }
            for (let i = 0; i < particlesArray.length; i++) { particlesArray[i].draw(); particlesArray[i].update(); }
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        initParticles(1); // Start with level 1 geo
        animate(0);

        console.log("Cyberpunk Geometry Loaded.");
    </script>
</body>
</html>
